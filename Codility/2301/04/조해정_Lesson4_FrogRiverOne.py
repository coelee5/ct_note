"""
개구리 현 위치 0, 목적지 위치 X+1, 그 사이 강물 위에 잎 떨어짐
배열 A, N개의 정수로 구성, 각 값은 잎의 위치를 의미. A[K]는 K초에 떨어진 잎 위치.
목적지까지 갈 수 있는 최소 시간을 찾는 것이 목적. 방법이 없다면 -1 반환.
1 ~ X 까지 잎은 모든 위치에 떨어져 있어야 건널 수 있다.

A[K] = X 이고, A[0] ~ A[K-1]에 1~X-1가 있다면 K반환?

1 <= N, X <= 100,000
배열 A의 각 요소 값 범위: 1<= A[i] <= X

경우1. 잎의 개수가 목적지에 비해 부족하다면 건널 수 없음.
경우2. 잎의 개수가 목적지와 같거나 커도 시작 위치와 목적지 위치 사이 각 단위에 잎이 하나라도 없다면 건널 수 없음.
경우3. 나머지는 다 건널 수 있으니, 모든 잎이 존재하는 최소 시간 반환.

Detected time complexity:
O(N)
"""


def solution(x, arr):
    ans = -1
    n = len(arr)

    if n < x:       # 경우1
        return ans

    # 각기 다른 위치의 잎이 나타날 때마다 +1
    # arr 가 한 바퀴 다 돌 때까지 cnt = x 하지 않으면 건널 수 없음
    cnt = 0

    # 1초가 지날 때마다 각 위치에 잎이 존재 하는지 확인할 배열, 값 1 ~ x
    leaf = [False] * x

    for k, val in enumerate(arr):
        if not leaf[val-1]:
            leaf[val-1] = True
            cnt += 1
            if cnt == x:    # 경우3, 루프가 끝날 때까지 만족 못 하면 경우2
                ans = k
                break
    return ans
